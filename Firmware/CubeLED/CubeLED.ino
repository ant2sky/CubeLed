/*
  Project : 
    Cube LED
  Module :
    Main function
  Description : 
    This module is the main module for cube LED project.
    
Version 0.1 :
  2013/10/29 -[Alen Chen] - Initial

*/

#include "LED.h"
#include "DataFormat.h"
#include "Communication.h"

#define DELAY_TIME	10

int lightControlPin = A0;
int lightControlValue = 0;

int lightLevel = 0;
int previousPhase = -1;

int stepCount = 0;
uint8_t phaseCount = 0;
int phaseTime = 0;

uint8_t ledData[4][2];

uint8_t package_A[] =
{
0xCC, 0x16, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 
0xAA, 0x01, 0x00, 0x32, 0x21, 0x84, 0x21, 0x84, 0x21, 0x84, 0x21, 0x84, 
0xAA, 0x01, 0x00, 0x32, 0x22, 0x44, 0x22, 0x44, 0x22, 0x44, 0x22, 0x44, 
0xAA, 0x01, 0x00, 0x32, 0x44, 0x22, 0x44, 0x22, 0x44, 0x22, 0x44, 0x22, 
0xAA, 0x01, 0x00, 0x32, 0x48, 0x12, 0x48, 0x12, 0x48, 0x12, 0x48, 0x12, 
0xAA, 0x01, 0x00, 0x32, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 
0xAA, 0x01, 0x00, 0x32, 0x30, 0x0C, 0x30, 0x0C, 0x30, 0x0C, 0x30, 0x0C, 
0xAA, 0x01, 0x00, 0x32, 0x21, 0x84, 0x21, 0x84, 0x21, 0x84, 0x21, 0x84, 
0xAA, 0x01, 0x00, 0x32, 0x21, 0x0C, 0x21, 0x0C, 0x21, 0x0C, 0x21, 0x0C, 
0xAA, 0x01, 0x00, 0x32, 0xE1, 0x00, 0xE1, 0x00, 0xE1, 0x00, 0xE1, 0x00, 
0xAA, 0x01, 0x00, 0x32, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 
0xAA, 0x01, 0x00, 0x32, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 
0xAA, 0x01, 0x00, 0x32, 0x2C, 0x01, 0x2C, 0x01, 0x2C, 0x01, 0x2C, 0x01, 
0xAA, 0x01, 0x00, 0x32, 0x48, 0x12, 0x48, 0x12, 0x48, 0x12, 0x48, 0x12, 
0xAA, 0x01, 0x00, 0x32, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 0x44, 0x12, 
0xAA, 0x01, 0x00, 0x32, 0x22, 0x12, 0x22, 0x12, 0x22, 0x12, 0x22, 0x12, 
0xAA, 0x01, 0x00, 0x32, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
0xAA, 0x01, 0x00, 0x32, 0x10, 0x31, 0x10, 0x31, 0x10, 0x31, 0x10, 0x31, 
0xAA, 0x01, 0x00, 0x32, 0x00, 0x71, 0x00, 0x71, 0x00, 0x71, 0x00, 0x71, 
0xAA, 0x01, 0x00, 0x32, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0xF0, 
0xAA, 0x01, 0x00, 0x32, 0x00, 0xE4, 0x00, 0xE4, 0x00, 0xE4, 0x00, 0xE4, 
0xAA, 0x01, 0x00, 0x32, 0x20, 0xC4, 0x20, 0xC4, 0x20, 0xC4, 0x20, 0xC4, 
0xAA, 0x01, 0x00, 0x32, 0x21, 0x84, 0x21, 0x84, 0x21, 0x84, 0x21, 0x84, 
};

uint8_t receiveBuffer[COM_RECEIVE_BUFFER_SIZE] = {0};
uint8_t ledDataBuffer[COM_RECEIVE_BUFFER_SIZE] = {0};
int ledDataSize = 0;
int receiveBufferIndex = 0;
int receiveMode = CMD_NULL;
int receiverDataSize = 0;
uint8_t checkSum = 0;

void setup() 
{
	Serial.begin(115200);
	pinMode(lightControlPin, OUTPUT);
	
	LED_setup();
}

void loop() 
{
         
	lightControlValue = analogRead(lightControlPin);
	//Serial.println(lightControlValue);
	lightControlValue = lightControlValue - (lightControlValue % LED_LIGHT_LEVEL_RANGE);
	if(lightLevel != (lightControlValue / LED_LIGHT_LEVEL_RANGE))
	{
		lightLevel = lightControlValue / LED_LIGHT_LEVEL_RANGE;
		LED_setLightLevel(lightLevel);
	}
	
    if(previousPhase != phaseCount)
    {
    	previousPhase = phaseCount;

		if(ledDataBuffer[0] == 0)
    		DF_handlePackage(&ledData[0][0], LED_CUBE_SIZE, package_A, sizeof(package_A), &phaseTime, &phaseCount);
    	else
    		DF_handlePackage(&ledData[0][0], LED_CUBE_SIZE, ledDataBuffer, ledDataSize, &phaseTime, &phaseCount);
		LED_setCube(&ledData[0][0], LED_CUBE_SIZE);
    }
    
	stepCount++;

	if(stepCount > phaseTime)
	{
	  stepCount = 0;
	  phaseCount++;
	}

	delay(DELAY_TIME);
}

void serialEvent()
{
	while(Serial.available())
	{
		bool isNewMode = false;
		
		uint8_t inChar = (uint8_t)Serial.read();

		if(receiveMode == CMD_NULL)
		{
			receiveMode = CM_checkCommand(inChar);
			isNewMode = true;
		}

		switch(receiveMode)
		{
		case CMD_CHECK_DEVICE:
			Serial.write(COM_TAG_CHECK_DEVICE);
			Serial.write(DEVICE_ID_4x4x4_CUBE_LED);
			resetReceiverStatus();
			break;
		case CMD_CHECK_TO_SEND:
			if(isNewMode)
				continue;
			pushCharToBuffer(inChar, receiveBuffer, &receiveBufferIndex);
			if(receiveBufferIndex >= DATA_SIZE_LEN)
			{
				receiverDataSize = receiveBuffer[1] << 8 | receiveBuffer[0];
				Serial.write(COM_TAG_CHECK_TO_SEND);
				Serial.write(receiveBuffer[0]);
				Serial.write(receiveBuffer[1]);
				resetReceiverStatus();
			}
			break;
		case CMD_SEND_DATA:
			if(isNewMode)
				continue;
			pushCharToBuffer(inChar, receiveBuffer, &receiveBufferIndex);
			if(receiveBufferIndex > receiverDataSize)
			{
				if(checkSum != receiveBuffer[receiveBufferIndex - 1])
				{
					Serial.write(COM_TAG_SEND_DATA);
					//Serial.write(COM_FAIL);
					Serial.write(checkSum);
				}
				else
				{
					uint8_t buffer[3];
					buffer[0] = COM_TAG_SEND_DATA;
					buffer[1] = receiverDataSize & 0x00FF;
					buffer[2] = (receiverDataSize & 0xFF00) >> 8;
					//Serial.write(COM_TAG_SEND_DATA);
					//Serial.write(receiverDataSize & 0x00FF);
					//Serial.write((receiverDataSize & 0xFF00) >> 8);
					Serial.write(buffer, 3);
					memcpy(ledDataBuffer, receiveBuffer, receiveBufferIndex);
					ledDataSize = receiverDataSize;
					stepCount = 0;
					phaseCount = 0;
					phaseTime = 0;
				}
				resetReceiverStatus();
			}
			else
			{
				checkSum += inChar;

			}
			break;
		default:
			Serial.write(inChar);
		}
	}
}

void pushCharToBuffer(uint8_t inChar, uint8_t * buffer, int * index)
{
	buffer[*index] = inChar;
	(*index)++;
}

void resetReceiverStatus()
{
	receiveMode = CMD_NULL;
	receiveBufferIndex = 0;
	checkSum = 0;
}
